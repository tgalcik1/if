<template>
    <div class="map">
        <p>Map</p>
        <div class="window" ref="mapWindow">
            <div class="current-location">
                <p>{{ playerLocation ? playerLocation.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ') : ""}}</p>
            </div>
            <!-- The D3 graph will be appended here -->
        </div>
    </div>
</template>

<!-- this script was generated by ChatGPT. im not a d3 expert and this is not a d3 class lol -->
<script>
import * as d3 from 'd3';

export default {
    name: 'MapView',
    data() {
        return {
            locations: {},
            connections: [],
            playerLocation: null,
            simulation: null,
            svg: null,
            linkGroup: null,
            nodeGroup: null,
            zoomableGroup: null
        };
    },
    mounted() {
        const container = this.$refs.mapWindow;
        const width = container.clientWidth;
        const height = container.clientHeight;

        // Setup SVG with a zoomable group
        this.svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .call(
                d3.zoom()
                    .scaleExtent([0.5, 2]) // Set min and max zoom levels
                    .on('zoom', this.zoomed)
            )
            .append('g'); // Append a group for zooming/panning

        this.zoomableGroup = this.svg.append('g');

        this.linkGroup = this.zoomableGroup.append('g').attr('class', 'links');
        this.nodeGroup = this.zoomableGroup.append('g').attr('class', 'nodes');

        this.simulation = d3.forceSimulation()
            .force('link', d3.forceLink().id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-200))
            .force('center', d3.forceCenter(width / 2, height / 2));

        if (window.api && window.api.receive) {
            window.api.receive('fromMain', (data) => {
                if (data.type === 'map-update') {
                    this.updateMap(data.locations, data.connections, data.player_location);
                }
            });
        }
    },
    methods: {
        /**
         * Updates the map by filtering nodes and connections to only include those
         * connected to the player's current location.
         * @param {Object} locations - The locations data.
         * @param {Array} connections - The connections data.
         * @param {String} playerLocation - The player's current location ID.
         */
        updateMap(locations, connections, playerLocation) {
            this.locations = locations;
            this.connections = connections;
            this.playerLocation = playerLocation;

            // Convert locations to nodes array
            const allNodes = Object.keys(locations).map(key => ({ id: key, name: locations[key].name }));

            // Convert connections to links array
            const allLinks = connections.map(conn => ({
                source: conn.source,
                target: conn.target
            }));

            // Get the connected component containing the player's location
            const connectedNodeIds = this.getConnectedComponent(playerLocation, allNodes, allLinks);

            // Filter nodes and links based on the connected component
            const filteredNodes = allNodes.filter(node => connectedNodeIds.has(node.id));
            const filteredLinks = allLinks.filter(link => 
                connectedNodeIds.has(link.source) && connectedNodeIds.has(link.target)
            );

            // Update links
            const linkSelection = this.linkGroup.selectAll('line')
                .data(filteredLinks, d => `${d.source}-${d.target}`);

            linkSelection.exit().remove();
            linkSelection.enter()
                .append('line')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6);

            // Update nodes
            const nodeSelection = this.nodeGroup.selectAll('circle')
                .data(filteredNodes, d => d.id);

            nodeSelection.exit().remove();
            const enteredNodes = nodeSelection.enter()
                .append('circle')
                .attr('r', 8)
                .attr('fill', d => d.id === this.playerLocation ? 'steelblue' : 'gray')
                .call(d3.drag()
                    .on('start', (event, d) => this.dragStarted(event, d))
                    .on('drag', (event, d) => this.dragged(event, d))
                    .on('end', (event, d) => this.dragEnded(event, d))
                );

            // Merge and update node attributes
            nodeSelection.merge(enteredNodes)
                .attr('fill', d => d.id === this.playerLocation ? 'steelblue' : 'gray');

            // Add labels
            const textSelection = this.nodeGroup.selectAll('text')
                .data(filteredNodes, d => d.id);

            textSelection.exit().remove();
            textSelection.enter()
                .append('text')
                .attr('dy', -10)
                .attr('text-anchor', 'middle')
                .attr('font-size', '10px')
                .attr('fill', 'black')
                .text(d => d.name);

            // Restart simulation with filtered data
            this.simulation
                .nodes(filteredNodes)
                .on('tick', this.ticked);

            this.simulation.force('link')
                .links(filteredLinks);

            this.simulation.alpha(1).restart();
        },

        /**
         * Performs a breadth-first search to find all nodes connected to the starting node.
         * @param {String} startId - The ID of the starting node.
         * @param {Array} nodes - The array of all nodes.
         * @param {Array} links - The array of all links.
         * @returns {Set} - A set of node IDs that are connected to the starting node.
         */
        getConnectedComponent(startId, nodes, links) {
            const adjacencyList = new Map();

            // Initialize adjacency list
            nodes.forEach(node => {
                adjacencyList.set(node.id, []);
            });

            // Populate adjacency list
            links.forEach(link => {
                adjacencyList.get(link.source).push(link.target);
                adjacencyList.get(link.target).push(link.source); // Assuming undirected graph
            });

            const visited = new Set();
            const queue = [startId];
            visited.add(startId);

            while (queue.length > 0) {
                const current = queue.shift();
                const neighbors = adjacencyList.get(current) || [];

                neighbors.forEach(neighbor => {
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push(neighbor);
                    }
                });
            }

            return visited;
        },

        ticked() {
            this.linkGroup.selectAll('line')
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            this.nodeGroup.selectAll('circle')
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);

            this.nodeGroup.selectAll('text')
                .attr('x', d => d.x)
                .attr('y', d => d.y - 15);
        },
        dragStarted(event, d) {
            if (!event.active) this.simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        },
        dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        },
        dragEnded(event, d) {
            if (!event.active) this.simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        },
        zoomed({ transform }) {
            this.zoomableGroup.attr('transform', transform);
        }
    }
};
</script>

<style scoped>
.map {
    margin: 16px;
}

.window {
    width: 100%;
    height: 300px;
    border: 2px solid black;
    box-sizing: border-box;

    background-image:
        linear-gradient(45deg, #bbb 25%, transparent 25%),
        linear-gradient(135deg, #bbb 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #bbb 75%),
        linear-gradient(135deg, transparent 75%, #bbb 75%);
    background-size: 25px 25px;
    background-position: 0 0, 12.5px 0, 12.5px -12.5px, 0px 12.5px;
    animation: scroll-checkerboard 2s linear infinite;
}

@keyframes scroll-checkerboard {
    0% {
        background-position: 0 0, 12.5px 0, 12.5px -12.5px, 0px 12.5px;
    }
    100% {
        background-position: 25px 25px, 37.5px 25px, 37.5px 12.5px, 25px 37.5px;
    }
}

.current-location{
    position: absolute;
    width: calc(100% - 38px);
    padding: 2px;
    text-align: center;
    background-color: rgba(0,0,0,0.6);
    color: rgb(220, 220, 220);
    border-bottom: 2px solid black;
    box-shadow: 0px 4px 1px rgba(0, 0, 0, 0.3);
}
</style>
